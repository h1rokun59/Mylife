name: Process Research Queue (Stepwise Worker)

on:
  workflow_run:
    workflows: ["Enqueue Research Requests"]
    types: [completed]
  schedule:
    - cron: "*/5 * * * *"
  workflow_dispatch:

concurrency:
  group: mylife-main-writes
  cancel-in-progress: false

jobs:
  process:
    if: github.repository == 'h1rokun59/Mylife' && (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success')
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "Process queue stepwise + Gemini step1 + SOC output for pro"
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GEMINI_MODEL_NORMAL: gemini-2.5-flash
          GEMINI_THINKING_BUDGET: "-1"
          ROUTER_PAT: ${{ secrets.ROUTER_PAT }}
          SOC_REPO_SLUG: soc-modernization
          SOC_OWNER: h1rokun59
        run: |
          set -euo pipefail

          NOW_EPOCH="$(date -u +%s)"
          NOW_UTC="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          echo "NOW_UTC=$NOW_UTC"
          echo "Event: $GITHUB_EVENT_NAME"

          PENDING_FILES=$(git ls-files 'research-queue/pending/*.json' || true)
          if [ -z "${PENDING_FILES}" ]; then
            echo "No pending queue files."
            exit 0
          fi

          mkdir -p research-results
          mkdir -p research-queue/processed

          processed_any=false
          SOC_CHANGED=false
          MYLIFE_RESULTS_CHANGED=false
          GEMINI_CALLS_THIS_RUN=0

          SOC_DIR="/tmp/${SOC_REPO_SLUG}"

          # --- helpers ---
          to_epoch() {
            local iso="$1"
            if [ -z "$iso" ] || [ "$iso" = "null" ]; then echo "0"; return; fi
            date -u -d "$iso" +%s 2>/dev/null || echo "0"
          }

          add_minutes() {
            local minutes="$1"
            date -u -d "${NOW_UTC} + ${minutes} minutes" +"%Y-%m-%dT%H:%M:%SZ"
          }

          write_md_lines() {
            local path="$1"; shift
            mkdir -p "$(dirname "$path")"
            { for line in "$@"; do printf '%s\n' "$line"; done; } > "$path"
          }

          step_file() {
            local step="$1"
            case "$step" in
              step1) echo "01-step1.md" ;;
              step2) echo "02-step2.md" ;;
              step3) echo "03-step3.md" ;;
              *) echo "00-unknown.md" ;;
            esac
          }

          next_step() {
            local step="$1"
            case "$step" in
              step1) echo "step2" ;;
              step2) echo "step3" ;;
              step3) echo "" ;;
              *) echo "" ;;
            esac
          }

          extract_idea_body() {
            local path="$1"
            if [ -z "$path" ] || [ ! -f "$path" ]; then echo ""; return; fi
            awk '
              /^---$/ { next }
              /^\*Captured via Idea Capture App\*$/ { next }
              /^# / { next }
              /^\*\*[A-Za-z0-9-]+:\*\* / { next }
              { print }
            ' "$path"
          }

          # pro tagkeys åˆ¤å®š
          is_pro_task() {
            local tagcsv="$1"
            echo ",$tagcsv," | grep -qiE ',(resilience|soc|threat-intel|cloud|ai-ml|architecture|people|process),'
          }

          # SOC repo cloneï¼ˆå¿…è¦æ™‚ã ã‘ï¼‰
          ensure_soc_repo() {
            if [ -d "${SOC_DIR}/.git" ]; then return 0; fi
            if [ -z "${ROUTER_PAT:-}" ]; then
              echo "ROUTER_PAT is not set. Cannot write to SOC repo."
              exit 2
            fi
            echo "Cloning SOC repo to ${SOC_DIR} ..."
            git clone "https://x-access-token:${ROUTER_PAT}@github.com/${SOC_OWNER}/${SOC_REPO_SLUG}.git" "${SOC_DIR}"
          }

          # Context Pack èª­ã¿è¾¼ã¿ï¼ˆå­˜åœ¨ã™ã‚Œã°ï¼‰
          read_ctx_file() {
            local rel="$1"
            local p="${SOC_DIR}/${rel}"
            if [ -f "$p" ]; then
              head -c 12000 "$p"
            else
              echo ""
            fi
          }

          gemini_generate() {
            local prompt="$1"
            local model="${GEMINI_MODEL_NORMAL:-gemini-2.5-flash}"
            local budget="${GEMINI_THINKING_BUDGET:--1}"

            if [ -z "${GEMINI_API_KEY:-}" ]; then
              echo "__ERROR__: GEMINI_API_KEY is not set"
              return 2
            fi

            local req
            req="$(jq -n \
              --arg p "$prompt" \
              --argjson b "$budget" \
              '{
                contents: [{ role: "user", parts: [{ text: $p }] }],
                generationConfig: { thinkingConfig: { thinkingBudget: $b } }
              }'
            )"

            local resp
            resp="$(curl -sS \
              -H "x-goog-api-key: ${GEMINI_API_KEY}" \
              -H "Content-Type: application/json" \
              -X POST \
              "https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent" \
              -d "$req"
            )" || { echo "__ERROR__: curl failed"; return 3; }

            if echo "$resp" | jq -e '.error' >/dev/null 2>&1; then
              echo "__ERROR__: $(echo "$resp" | jq -r '.error.message // "unknown error"')"
              return 4
            fi

            local text
            text="$(echo "$resp" | jq -r '[.candidates[0].content.parts[]?.text] | join("\n")' 2>/dev/null || true)"
            if [ -z "$text" ] || [ "$text" = "null" ]; then
              echo "__ERROR__: empty response text"
              return 5
            fi

            printf '%s' "$text"
            return 0
          }

          # SOC pushï¼ˆrebase retryï¼‰
          push_soc_repo() {
            local msg="$1"
            if [ "$SOC_CHANGED" != "true" ]; then return 0; fi

            echo "Committing/pushing to SOC repo..."
            git -C "${SOC_DIR}" config user.email "actions@github.com"
            git -C "${SOC_DIR}" config user.name "GitHub Actions"

            git -C "${SOC_DIR}" add research-results research-context 2>/dev/null || true
            git -C "${SOC_DIR}" commit -m "$msg" || echo "Nothing to commit in SOC."

            for i in 1 2 3; do
              echo "SOC push attempt $i..."
              git -C "${SOC_DIR}" fetch origin main
              if git -C "${SOC_DIR}" rebase origin/main; then
                if git -C "${SOC_DIR}" push; then
                  echo "SOC push succeeded."
                  return 0
                fi
              else
                echo "SOC rebase failed, aborting."
                git -C "${SOC_DIR}" rebase --abort || true
              fi
              sleep $((i * 2))
            done

            echo "SOC push failed after retries."
            return 1
          }

          echo "Pending queue files:"
          echo "${PENDING_FILES}"

          while IFS= read -r qfile; do
            [ -z "$qfile" ] && continue
            [ ! -f "$qfile" ] && continue

            echo "----------------------------------------"
            echo "Queue: $qfile"

            IDEA_ID=$(jq -r '.idea_id // ""' "$qfile")
            STATUS=$(jq -r '.status // ""' "$qfile")

            MODE=$(jq -r '.execution.mode // "normal"' "$qfile")
            ONE_STEP_PER_RUN=$(jq -r '.execution.one_step_per_run // true' "$qfile")
            COOLDOWN_MIN=$(jq -r '.execution.cooldown_minutes_between_steps // 15' "$qfile")

            CUR_STEP=$(jq -r '.state.current_step // "step1"' "$qfile")
            NEXT_ELIGIBLE=$(jq -r '.state.next_eligible_at_utc // ""' "$qfile")

            TITLE=$(jq -r '.idea.title // ""' "$qfile")
            TAG_KEYS=$(jq -r '(.idea.tag_keys // []) | join(",")' "$qfile")
            ACTIONS=$(jq -r '(.idea.actions // []) | join(",")' "$qfile")
            SOURCE_URL=$(jq -r '.source.url // ""' "$qfile")
            SOURCE_PATH=$(jq -r '.source.path // ""' "$qfile")

            if [ -z "$IDEA_ID" ]; then IDEA_ID="$(basename "$qfile" .json)"; fi
            if [ "$STATUS" != "pending" ]; then continue; fi

            NEXT_EPOCH="$(to_epoch "$NEXT_ELIGIBLE")"
            if [ "$NEXT_EPOCH" -gt "$NOW_EPOCH" ]; then
              echo "Skip: not eligible yet. next_eligible_at_utc=$NEXT_ELIGIBLE"
              continue
            fi

            # proãªã‚‰SOCã¸å‡ºåŠ›
            TARGET="mylife"
            if [ "$MODE" = "super-heavy" ] || is_pro_task "$TAG_KEYS"; then
              TARGET="soc"
              ensure_soc_repo
            fi

            # free-tier: Normal step1 ã¯ Gemini 1å›ž/Run
            if [ "$MODE" = "normal" ] && [ "$CUR_STEP" = "step1" ] && [ "$GEMINI_CALLS_THIS_RUN" -ge 1 ]; then
              echo "Skip: Gemini call limit reached for this run (1 call)."
              continue
            fi

            # output dir
            OUT_DIR_MYLIFE="research-results/${IDEA_ID}"
            OUT_DIR_SOC="${SOC_DIR}/research-results/${IDEA_ID}"
            OUT_DIR="$OUT_DIR_MYLIFE"
            if [ "$TARGET" = "soc" ]; then OUT_DIR="$OUT_DIR_SOC"; fi
            mkdir -p "$OUT_DIR"

            # steps to run this round
            steps_to_run=()
            if [ "$MODE" = "super-heavy" ] && [ "$ONE_STEP_PER_RUN" = "false" ]; then
              s="$CUR_STEP"
              while [ -n "$s" ]; do steps_to_run+=("$s"); s="$(next_step "$s")"; done
            else
              steps_to_run+=("$CUR_STEP")
            fi

            echo "Target=$TARGET Mode=$MODE current_step=$CUR_STEP steps_to_run=${steps_to_run[*]}"

            for s in "${steps_to_run[@]}"; do
              sf="$(step_file "$s")"
              step_path="${OUT_DIR}/${sf}"

              if [ "$MODE" = "normal" ] && [ "$s" = "step1" ]; then
                IDEA_BODY="$(extract_idea_body "$SOURCE_PATH")"

                # Context Packï¼ˆSOC taskæ™‚ã®ã¿æ³¨å…¥ï¼‰
                CTX=""
                if [ "$TARGET" = "soc" ]; then
                  CTX_MUST="$(read_ctx_file 'research-context/00-MUST-READ.md')"
                  CTX_GUARD="$(read_ctx_file 'research-context/20-research-guardrails.md')"
                  CTX_STEP1="$(read_ctx_file 'research-context/3step/step1-instructions.md')"
                  CTX="$(printf '%s\n\n%s\n\n%s\n' "$CTX_MUST" "$CTX_GUARD" "$CTX_STEP1")"
                fi

                PROMPT="$(
                  {
                    printf '%s\n' 'ã‚ãªãŸã¯ãƒªã‚µãƒ¼ãƒæ”¯æ´AIã§ã™ã€‚ã„ã¾ã‹ã‚‰ã€Œ3Stepèª¿æŸ»ãƒ—ãƒ­ã‚»ã‚¹ã®Step1ï¼ˆè«–ç‚¹æ•´ç†ï¼‹èª¿æŸ»è¨­è¨ˆï¼‰ã€ã ã‘ã‚’å®Ÿæ–½ã—ã¦ãã ã•ã„ã€‚'
                    printf '\n'
                    printf '%s\n' 'åˆ¶ç´„:'
                    printf '%s\n' '- ã„ã¾ã¯å¤–éƒ¨Webæ¤œç´¢ã¯ã—ã¾ã›ã‚“ï¼ˆäº‹å®Ÿã®æ–­å®šã‚ˆã‚Šã€èª¿æŸ»è¨­è¨ˆã¨è«–ç‚¹æ•´ç†ã«é›†ä¸­ï¼‰'
                    printf '%s\n' '- ç¤¾å†…æ©Ÿå¯†ãƒ»å›ºæœ‰åè©žãƒ»å€‹äººæƒ…å ±ã¯å‡ºåŠ›ã«å«ã‚ãªã„ï¼ˆä¸Žãˆã‚‰ã‚Œã¦ã„ã¦ã‚‚æŠ½è±¡åŒ–ï¼‰'
                    printf '%s\n' '- ä¸ç¢ºå®Ÿãªã“ã¨ã¯ã€Œæœªç¢ºèªã€ã¨æ˜Žè¨˜'
                    printf '%s\n' '- å‡ºåŠ›ã¯Markdownã®ã¿'
                    printf '\n'
                    if [ -n "$CTX" ]; then
                      printf '%s\n' '---'
                      printf '%s\n' 'Context Pack (MUST READ):'
                      printf '%s\n' "$CTX"
                      printf '\n'
                    fi
                    printf '%s\n' 'å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆ:'
                    printf '%s\n' '## TL;DR'
                    printf '%s\n' '## èª¿æŸ»ç›®çš„'
                    printf '%s\n' '## ã‚¹ã‚³ãƒ¼ãƒ— / éžã‚¹ã‚³ãƒ¼ãƒ—'
                    printf '%s\n' '## ä¸»è¦ãªè«–ç‚¹ï¼ˆ3ã€œ7ï¼‰'
                    printf '%s\n' '## ä»®èª¬ï¼ˆã‚ã‚Œã°ï¼‰'
                    printf '%s\n' '## åŽé›†ã™ã¹ãä¸€æ¬¡æƒ…å ±ï¼ˆã‚«ãƒ†ã‚´ãƒªã§ï¼šå…¬å¼Doc/RFC/NIST/MITREç­‰ï¼‰'
                    printf '%s\n' '## 15åˆ†Ã—3Stepå‰æã®é€²ã‚æ–¹ï¼ˆStep1â†’Step2â†’Step3ã®è¦ç‚¹ï¼‰'
                    printf '%s\n' '## æœªç¢ºèªç‚¹ãƒ»ãƒªã‚¹ã‚¯'
                    printf '%s\n' '## æ¬¡ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆå…·ä½“çš„ã«ï¼‰'
                    printf '\n'
                    printf '%s\n' 'å…¥åŠ›ï¼ˆã‚¢ã‚¤ãƒ‡ã‚¢ï¼‰:'
                    printf '%s\n' "- Title: ${TITLE}"
                    printf '%s\n' "- TagKeys: ${TAG_KEYS}"
                    printf '%s\n' "- Actions: ${ACTIONS}"
                    printf '%s\n' "- Source: ${SOURCE_URL}"
                    printf '\n'
                    printf '%s\n' '---'
                    printf '%s\n' "${IDEA_BODY}"
                  }
                )"

                echo "Calling Gemini for step1..."
                GEMINI_CALLS_THIS_RUN=$((GEMINI_CALLS_THIS_RUN + 1))

                set +e
                OUT="$(gemini_generate "$PROMPT")"
                RC=$?
                set -e

                if [ $RC -ne 0 ] || echo "$OUT" | grep -q '^__ERROR__:'; then
                  echo "Gemini error: $OUT"
                  write_md_lines "$step_path" \
                    "# ðŸ§© step1 (Gemini ERROR)" \
                    "" \
                    "**Idea-ID:** ${IDEA_ID}" \
                    "**Mode:** ${MODE}" \
                    "**Target:** ${TARGET}" \
                    "**Ran-At-UTC:** ${NOW_UTC}" \
                    "" \
                    "## Error" \
                    "${OUT}" \
                    "" \
                    "## Action" \
                    "- GEMINI_API_KEY / quota ã‚’ç¢ºèªã—ã¦å†å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚"
                  processed_any=true
                  if [ "$TARGET" = "soc" ]; then SOC_CHANGED=true; else MYLIFE_RESULTS_CHANGED=true; fi
                  continue 2
                fi

                mkdir -p "$(dirname "$step_path")"
                {
                  printf '# ðŸ§© step1 (Gemini Thinking)\n\n'
                  printf '**Idea-ID:** %s\n' "$IDEA_ID"
                  printf '**Mode:** %s\n' "$MODE"
                  printf '**Target:** %s\n' "$TARGET"
                  printf '**Ran-At-UTC:** %s\n\n' "$NOW_UTC"
                  printf '%s\n' "$OUT"
                } > "$step_path"

                if [ "$TARGET" = "soc" ]; then SOC_CHANGED=true; else MYLIFE_RESULTS_CHANGED=true; fi

              else
                write_md_lines "$step_path" \
                  "# ðŸ§© ${s} (placeholder)" \
                  "" \
                  "**Idea-ID:** ${IDEA_ID}" \
                  "**Mode:** ${MODE}" \
                  "**Target:** ${TARGET}" \
                  "**Title:** ${TITLE}" \
                  "**TagKeys:** ${TAG_KEYS}" \
                  "**Actions:** ${ACTIONS}" \
                  "**Source:** ${SOURCE_URL}" \
                  "**Ran-At-UTC:** ${NOW_UTC}" \
                  "" \
                  "## Output (Dummy)" \
                  "- Placeholder step output." \
                  "- Later: Normal=Gemini Thinking, Super Heavy=Claude Code orchestration."

                if [ "$TARGET" = "soc" ]; then SOC_CHANGED=true; else MYLIFE_RESULTS_CHANGED=true; fi
              fi
            done

            LAST_STEP_RUN="${steps_to_run[-1]}"
            NEXT_STEP="$(next_step "$LAST_STEP_RUN")"

            if [ -z "$NEXT_STEP" ]; then
              # done â†’ processedï¼ˆMylifeå´ã®queueã« resultå‚ç…§ã‚’æ®‹ã™ï¼‰
              PROCESSED_Q="research-queue/processed/${IDEA_ID}.json"

              RESULT_REPO="$GITHUB_REPOSITORY"
              RESULT_DIR="$OUT_DIR_MYLIFE"
              if [ "$TARGET" = "soc" ]; then
                RESULT_REPO="${SOC_OWNER}/${SOC_REPO_SLUG}"
                RESULT_DIR="research-results/${IDEA_ID}"
              fi

              jq \
                --arg processed_at_utc "$NOW_UTC" \
                --arg result_repo "$RESULT_REPO" \
                --arg result_dir "$RESULT_DIR" \
                '
                .status = "done"
                | .state.status = "done"
                | .state.current_step = null
                | .state.next_eligible_at_utc = null
                | .process = {
                    processed_at_utc: $processed_at_utc,
                    worker: { name: "github-actions-stepwise-worker", version: 3 },
                    mode: "gemini-step1+soc-output"
                  }
                | .result = { repo: $result_repo, dir: $result_dir }
                ' "$qfile" > "$PROCESSED_Q"

              git rm -f "$qfile"
              processed_any=true
            else
              next_eligible="$NOW_UTC"
              if [ "$COOLDOWN_MIN" != "0" ] && [ "$COOLDOWN_MIN" != "null" ]; then
                next_eligible="$(add_minutes "$COOLDOWN_MIN")"
              fi

              tmp="/tmp/${IDEA_ID}.json"
              jq \
                --arg now "$NOW_UTC" \
                --arg next_step "$NEXT_STEP" \
                --arg next_eligible "$next_eligible" \
                --arg mode "$MODE" \
                '
                .status = "pending"
                | .execution.mode = $mode
                | .state.status = "queued"
                | .state.current_step = $next_step
                | .state.next_eligible_at_utc = $next_eligible
                | .state.completed_steps = (
                    (.state.completed_steps // [])
                    + [ "'"$CUR_STEP"'" ]
                    | unique
                  )
                | .state.last_run_at_utc = $now
                ' "$qfile" > "$tmp"

              mv "$tmp" "$qfile"
              processed_any=true
            fi

          done <<< "$PENDING_FILES"

          if [ "$processed_any" != "true" ]; then
            echo "No eligible queue items processed."
            exit 0
          fi

          # --- push SOC repo (if changed) ---
          if [ "$SOC_CHANGED" = "true" ]; then
            push_soc_repo "ðŸ”Ž update research results"
          fi

          # --- commit/push Mylife changes (queue + life results) ---
          if [ -z "$(git status --porcelain -- research-queue research-results)" ]; then
            echo "No Mylife changes to commit."
            exit 0
          fi

          git config user.email "actions@github.com"
          git config user.name "GitHub Actions"

          git add research-queue research-results
          git commit -m "ðŸ¤– stepwise process research queue (soc output for pro)" || echo "Nothing to commit."

          for i in 1 2 3; do
            echo "Mylife push attempt $i..."
            git fetch origin main
            if git rebase origin/main; then
              if git push; then
                echo "Mylife push succeeded."
                break
              fi
            else
              git rebase --abort || true
            fi
            sleep $((i * 2))
          done